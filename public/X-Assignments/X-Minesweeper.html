<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minesweeper</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            color: #1a202c;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #e2e8f0;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            max-width: 90vw;
        }

        .info-panel {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            font-weight: bold;
            font-size: 1.25rem;
            color: #2d3748;
        }

        .game-board {
            display: grid;
            gap: 2px;
            border: 4px solid #99aab5;
        }

        .cell {
            width: 32px;
            height: 32px;
            background-color: #cbd5e0;
            border-top: 3px solid #f0f4f8;
            border-left: 3px solid #f0f4f8;
            border-right: 3px solid #718096;
            border-bottom: 3px solid #718096;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 1.25rem;
            color: transparent;
            user-select: none;
        }
        
        .cell.revealed {
            background-color: #e2e8f0;
            border: 1px solid #a0aec0;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.1);
            cursor: default;
        }
        
        .cell.revealed.mine {
            background-color: #f87171;
            color: #fff;
        }
        
        .cell.flagged {
            background-color: #b794f4;
        }

        .number-1 { color: #1e40af; }
        .number-2 { color: #166534; }
        .number-3 { color: #9a3412; }
        .number-4 { color: #431c9a; }
        .number-5 { color: #854d0e; }
        .number-6 { color: #0f766e; }
        .number-7 { color: #6b21a8; }
        .number-8 { color: #1f2937; }

        .mine-icon {
            font-size: 1.5rem;
            color: #ef4444;
        }

        .message-box {
            font-size: 1.5rem;
            font-weight: bold;
            text-align: center;
            margin-top: 1rem;
            padding: 1rem;
            border-radius: 0.5rem;
        }

        .message-win {
            background-color: #d1fae5;
            color: #065f46;
        }
        
        .message-lose {
            background-color: #fee2e2;
            color: #b91c1c;
        }

        .play-again-btn {
            background-color: #4a5568;
            color: #fff;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .play-again-btn:hover {
            background-color: #2d3748;
        }
    </style>
</head>
<body oncontextmenu="return false;">

    <div class="game-container">
        <div class="info-panel">
            <span id="flag-count">üö© 0</span>
            <button id="reset-button" class="play-again-btn">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-6 h-6 inline-block mr-1">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181-3.183a8.25 8.25 0 0113.803-3.7M4.031 9.865a8.25 8.25 0 0113.803-3.7l3.181 3.182m0-4.991v4.99" />
                </svg>
                Reset
            </button>
            <span id="timer">‚è±Ô∏è 0</span>
        </div>
        <div id="game-message" class="message-box"></div>
        <div id="game-board" class="game-board"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const board = document.getElementById('game-board');
            const flagCountElement = document.getElementById('flag-count');
            const timerElement = document.getElementById('timer');
            const resetButton = document.getElementById('reset-button');
            const gameMessageElement = document.getElementById('game-message');

            const ROWS = 16;
            const COLS = 16;
            const MINES = 40;
            let cells = [];
            let boardArray = [];
            let flagsPlaced = 0;
            let gameOver = false;
            let timerInterval;
            let time = 0;
            let isFirstClick = true;

            function showMessage(message, isWin) {
                gameMessageElement.textContent = message;
                gameMessageElement.classList.remove('message-win', 'message-lose');
                if (isWin) {
                    gameMessageElement.classList.add('message-win');
                } else {
                    gameMessageElement.classList.add('message-lose');
                }
            }

            function startTimer() {
                if (timerInterval) clearInterval(timerInterval);
                time = 0;
                timerElement.textContent = `‚è±Ô∏è ${time}`;
                timerInterval = setInterval(() => {
                    time++;
                    timerElement.textContent = `‚è±Ô∏è ${time}`;
                }, 1000);
            }

            function stopTimer() {
                clearInterval(timerInterval);
            }
            
            function createBoard() {
                board.innerHTML = '';
                board.style.gridTemplateColumns = `repeat(${COLS}, 1fr)`;
                cells = [];
                boardArray = [];
                flagsPlaced = 0;
                gameOver = false;
                isFirstClick = true;
                flagCountElement.textContent = `üö© ${MINES - flagsPlaced}`;
                gameMessageElement.textContent = '';
                gameMessageElement.classList.remove('message-win', 'message-lose');
                
                for (let r = 0; r < ROWS; r++) {
                    boardArray[r] = [];
                    for (let c = 0; c < COLS; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        board.appendChild(cell);
                        cells.push(cell);
                        boardArray[r][c] = {
                            isMine: false,
                            isRevealed: false,
                            isFlagged: false,
                            minesAround: 0,
                            element: cell
                        };
                    }
                }
            }
            
            function placeMines(firstClickR, firstClickC) {
                let minesPlaced = 0;
                while (minesPlaced < MINES) {
                    const r = Math.floor(Math.random() * ROWS);
                    const c = Math.floor(Math.random() * COLS);
                    
                    // Don't place a mine on the first click cell or its neighbors
                    let isSafe = true;
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            if (firstClickR + dr === r && firstClickC + dc === c) {
                                isSafe = false;
                            }
                        }
                    }

                    if (!boardArray[r][c].isMine && isSafe) {
                        boardArray[r][c].isMine = true;
                        minesPlaced++;
                    }
                }
            }
            
            function calculateMinesAround() {
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (boardArray[r][c].isMine) {
                            boardArray[r][c].minesAround = 0;
                            continue;
                        }
                        
                        let count = 0;
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                if (dr === 0 && dc === 0) continue;
                                const newR = r + dr;
                                const newC = c + dc;
                                
                                if (newR >= 0 && newR < ROWS && newC >= 0 && newC < COLS && boardArray[newR][newC].isMine) {
                                    count++;
                                }
                            }
                        }
                        boardArray[r][c].minesAround = count;
                    }
                }
            }
            
            function showAllCellsOnGameOver() {
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        const cell = boardArray[r][c];
                        cell.element.classList.add('revealed');
                        cell.isRevealed = true; // Mark as revealed to prevent further clicks
                        
                        if (cell.isMine) {
                            if (cell.isFlagged) {
                                // Correctly flagged mines stay flagged
                                cell.element.innerHTML = '<span>üö©</span>';
                            } else {
                                cell.element.classList.add('mine');
                                cell.element.innerHTML = '<span class="mine-icon">üí£</span>';
                            }
                        } else {
                            if (cell.isFlagged) {
                                // Incorrectly flagged non-mines show an X
                                cell.element.innerHTML = '<span>‚ùå</span>';
                            } else if (cell.minesAround > 0) {
                                // Show number for unflagged non-mines
                                cell.element.textContent = cell.minesAround;
                                cell.element.classList.add(`number-${cell.minesAround}`);
                            } else {
                                // Show blank for unflagged non-mines with 0 count
                                cell.element.textContent = '';
                            }
                        }
                    }
                }
            }
            
            function revealCell(r, c) {
                if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return;
                const cell = boardArray[r][c];
                if (cell.isRevealed || cell.isFlagged || gameOver) return;

                cell.isRevealed = true;
                cell.element.classList.add('revealed');
                
                if (cell.isMine) {
                    gameOver = true;
                    stopTimer();
                    showAllCellsOnGameOver();
                    showMessage("Game Over! You hit a mine.", false);
                    return;
                }
                
                if (cell.minesAround > 0) {
                    cell.element.textContent = cell.minesAround;
                    cell.element.classList.add(`number-${cell.minesAround}`);
                } else {
                    // Reveal adjacent cells if this one has no mines around
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            revealCell(r + dr, c + dc);
                        }
                    }
                }
                
                checkWin();
            }
            
            function checkWin() {
                let revealedCells = 0;
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (boardArray[r][c].isRevealed) {
                            revealedCells++;
                        }
                    }
                }
                
                if (revealedCells === (ROWS * COLS) - MINES) {
                    gameOver = true;
                    stopTimer();
                    showAllCellsOnGameOver();
                    showMessage("Congratulations! You won!", true);
                }
            }
            
            function handleLeftClick(event) {
                const cellElement = event.target.closest('.cell');
                if (!cellElement) return;
                
                const r = parseInt(cellElement.dataset.row);
                const c = parseInt(cellElement.dataset.col);
                
                if (gameOver) return;
                
                const cell = boardArray[r][c];
                if (cell.isFlagged) return;

                if (isFirstClick) {
                    // Place mines and calculate numbers on the first click
                    placeMines(r, c);
                    calculateMinesAround();
                    isFirstClick = false;
                    startTimer();
                } else if (cell.isRevealed) {
                    // Multiclick logic for a revealed cell
                    if (cell.minesAround > 0) {
                        let flaggedNeighbors = 0;
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                if (dr === 0 && dc === 0) continue;
                                const newR = r + dr;
                                const newC = c + dc;
                                
                                if (newR >= 0 && newR < ROWS && newC >= 0 && newC < COLS) {
                                    if (boardArray[newR][newC].isFlagged) {
                                        flaggedNeighbors++;
                                    }
                                }
                            }
                        }

                        if (flaggedNeighbors === cell.minesAround) {
                            for (let dr = -1; dr <= 1; dr++) {
                                for (let dc = -1; dc <= 1; dc++) {
                                    if (dr === 0 && dc === 0) continue;
                                    const newR = r + dr;
                                    const newC = c + dc;
                                    
                                    if (newR >= 0 && newR < ROWS && newC >= 0 && newC < COLS) {
                                        const neighbor = boardArray[newR][newC];
                                        if (!neighbor.isRevealed && !neighbor.isFlagged) {
                                            revealCell(newR, newC);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return; // Prevent revealing the same cell again
                }
                
                revealCell(r, c);
            }
            
            function handleRightClick(event) {
                event.preventDefault();
                const cellElement = event.target.closest('.cell');
                if (!cellElement) return;
                
                const r = parseInt(cellElement.dataset.row);
                const c = parseInt(cellElement.dataset.col);
                
                if (gameOver) return;
                
                const cell = boardArray[r][c];
                if (cell.isRevealed) return;
                
                if (cell.isFlagged) {
                    cell.isFlagged = false;
                    cellElement.classList.remove('flagged');
                    cellElement.innerHTML = '';
                    flagsPlaced--;
                } else if (flagsPlaced < MINES) {
                    cell.isFlagged = true;
                    cellElement.classList.add('flagged');
                    cellElement.innerHTML = '<span>üö©</span>';
                    flagsPlaced++;
                }
                flagCountElement.textContent = `üö© ${MINES - flagsPlaced}`;
            }

            function resetGame() {
                stopTimer();
                createBoard();
            }
            
            board.addEventListener('click', handleLeftClick);
            board.addEventListener('contextmenu', handleRightClick);
            resetButton.addEventListener('click', resetGame);
            
            resetGame();
        });
    </script>

</body>
</html>
